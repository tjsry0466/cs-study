# Redis 캐시 전략

캐싱 전략은 웹 서비스 환경에서 시스템 성능을 향상시키는 중요한 기술입니다. 일반적으로 캐시는 메모리(RAM)를 사용하여 데이터베이스보다 훨씬 빠르게 데이터를 응답할 수 있어, 이용자에게 신속한 서비스를 제공합니다. 그러나 RAM 용량이 제한적이므로, 어떤 데이터를 캐시에 저장할지, 얼마나 오래 저장할지 등에 대한 명확한 전략이 필요합니다.

## 캐시 활용의 중요성

- **효율적인 캐시 사용**: 자주 조회되거나 연산이 필요한 데이터를 캐싱하면 성능을 크게 향상시킬 수 있습니다.
- **캐시 용량 관리**: RAM의 용량은 제한적이므로, 저장할 데이터를 선별하여 효율적으로 사용해야 합니다.

## 캐싱 전략 패턴

캐시를 사용할 때 데이터 정합성 문제를 해결하기 위한 다양한 전략이 필요합니다.

### 캐시 읽기 전략 (Read Cache Strategy)

#### Look Aside 패턴 (Cache Aside)

- **작동 방식**: 데이터 조회 시 캐시를 먼저 확인하고, 캐시에 데이터가 없으면 DB에서 데이터를 가져와 캐시에 저장합니다.
- **장점**: 캐시와 DB가 분리되어 있어 캐시 장애 발생 시에도 서비스 중단 없이 DB에서 데이터를 가져올 수 있습니다.
- **단점**: 캐시와 DB 간 데이터 정합성 문제가 발생할 수 있으며, 초기 조회 시 DB에 부하가 집중될 수 있습니다.
- **적합한 경우**: 반복적인 조회가 많은 서비스에 적합합니다.

#### Read Through 패턴

- **작동 방식**: 캐시 제공자가 데이터를 캐시에서 읽어오며, 데이터 동기화도 캐시 제공자가 처리합니다. 캐시에 데이터가 없으면 DB에서 조회한 후 캐시에 저장하고 데이터를 반환합니다.
- **장점**: 캐시와 DB 간 데이터 정합성이 유지되며, 애플리케이션에서 데이터 동기화를 직접 처리할 필요가 없습니다.
- **단점**: 캐시에 문제가 발생하면 서비스 중단이 우려되며, 캐시 제공자에 대한 의존성이 큽니다.
- **적합한 경우**: 읽기 작업이 많은 워크로드에 적합합니다.

### 캐시 쓰기 전략 (Write Cache Strategy)

#### Write Back 패턴 (Write Behind)

- **작동 방식**: 데이터를 캐시에 먼저 저장하고, 일정 주기마다 DB에 비동기로 반영합니다.
- **장점**: DB에 대한 쓰기 부하를 줄일 수 있으며, 쓰기 작업이 많은 서비스에 적합합니다.
- **단점**: 캐시 장애 시 데이터 유실 가능성이 있으며, 데이터 정합성을 유지하기 어렵습니다.
- **적합한 경우**: 빈번한 쓰기 작업이 발생하고, DB에 대한 쓰기 부하를 줄여야 하는 경우에 적합합니다.

#### Write Through 패턴

- **작동 방식**: 데이터를 캐시에 저장한 후, 즉시 DB에도 저장합니다. 캐시와 DB의 데이터가 항상 동기화됩니다.
- **장점**: 캐시와 DB 간의 데이터가 항상 일치하여 일관성을 유지할 수 있습니다.
- **단점**: 모든 쓰기 작업이 캐시와 DB에 동시에 이루어지므로 성능이 저하될 수 있습니다.
- **적합한 경우**: 데이터 일관성이 중요한 애플리케이션에서 사용되며, 쓰기 작업이 빈번한 경우에 적합합니다.

#### Write Around 패턴

- **작동 방식**: 데이터를 DB에만 저장하고 캐시에는 저장하지 않으며, 캐시 미스가 발생할 때만 캐시를 갱신합니다.
- **장점**: 빠른 쓰기 성능을 제공합니다.
- **단점**: 캐시와 DB 간 데이터 불일치가 발생할 수 있습니다.
- **적합한 경우**: 데이터 수정 후 곧바로 읽히지 않거나, 쓰기 작업이 많은 경우에 적합합니다.

### 캐시 읽기 + 쓰기 전략 조합

### 1. Look Aside + Write Around 조합

이 조합은 캐시 읽기 전략으로 Look Aside 패턴을, 쓰기 전략으로 Write Around 패턴을 사용하는 방식입니다.

- **작동 방식**:

  1. **읽기**: 애플리케이션이 데이터를 요청할 때 먼저 캐시를 확인합니다. 캐시에 데이터가 있으면 이를 반환하고(Cache Hit), 없으면 DB에서 데이터를 조회한 후 캐시에 저장합니다(Cache Miss).
  2. **쓰기**: 데이터는 DB에만 저장되며, 캐시는 갱신하지 않습니다. 캐시 미스 시에만 캐시를 갱신합니다.

- **장점**:

  - 캐시의 쓰기 부하를 줄여 캐시 용량을 효율적으로 사용할 수 있습니다.
  - 캐시와 DB가 분리되어 있어, 캐시 장애 시에도 서비스 중단 없이 DB에서 데이터를 가져올 수 있습니다.

- **단점**:

  - 캐시와 DB 간 데이터 불일치가 발생할 수 있습니다. 특히, DB에서 데이터가 수정된 경우 캐시에는 여전히 오래된 데이터가 남아 있을 수 있습니다.
  - 캐시 미스가 발생할 때 초기 데이터 조회가 느려질 수 있습니다.

- **적합한 경우**:
  - 읽기 작업이 많고, 쓰기 작업은 상대적으로 적은 애플리케이션에서 유리합니다.
  - 캐시 용량이 제한적이고, 최신 데이터가 항상 필요하지 않은 경우 적합합니다.

### 2. Read Through + Write Around 조합

이 조합은 캐시 읽기 전략으로 Read Through 패턴을, 쓰기 전략으로 Write Around 패턴을 사용하는 방식입니다.

- **작동 방식**:

  1. **읽기**: 애플리케이션이 데이터를 요청하면, 캐시 제공자가 캐시에서 데이터를 읽어옵니다. 캐시에 데이터가 없으면 DB에서 데이터를 조회한 후 캐시에 저장합니다.
  2. **쓰기**: 데이터는 DB에만 저장되며, 캐시는 갱신하지 않습니다. 캐시 미스 시에만 캐시를 갱신합니다.

- **장점**:

  - 캐시와 DB 간의 데이터 동기화가 자동으로 이루어져, 데이터 정합성을 유지할 수 있습니다.
  - 캐시 쓰기 부하를 줄여 캐시 용량을 효율적으로 사용할 수 있습니다.

- **단점**:

  - 캐시와 DB 간의 데이터 불일치가 발생할 수 있습니다. 특히, DB에서 데이터가 수정된 경우 캐시에는 여전히 오래된 데이터가 남아 있을 수 있습니다.
  - 캐시 미스가 발생하면 데이터베이스를 조회해야 하므로 초기 조회가 느려질 수 있습니다.
  - 캐시 제공자에 대한 의존성이 높아져, 캐시 장애 시 서비스가 중단될 위험이 있습니다.

- **적합한 경우**:
  - 데이터 일관성이 중요하지만, 쓰기 작업이 많은 애플리케이션에서 사용됩니다.
  - 캐시 용량이 제한적이고, 최신 데이터가 항상 필요하지 않은 경우 적합합니다.

### 3. Read Through + Write Through 조합

이 조합은 캐시 읽기 전략으로 Read Through 패턴을, 쓰기 전략으로 Write Through 패턴을 사용하는 방식입니다.

- **작동 방식**:

  1. **읽기**: 애플리케이션이 데이터를 요청하면, 캐시 제공자가 캐시에서 데이터를 읽어옵니다. 캐시에 데이터가 없으면 DB에서 데이터를 조회한 후 캐시에 저장하고, 애플리케이션에 반환합니다.
  2. **쓰기**: 데이터를 캐시에 먼저 저장한 후, 즉시 DB에도 저장합니다. 이를 통해 캐시와 DB 간의 데이터 일관성이 유지됩니다.

- **장점**:

  - 캐시와 DB 간의 데이터 일관성이 보장되므로, 데이터의 최신 상태를 항상 유지할 수 있습니다.
  - 읽기와 쓰기 작업이 일관되게 이루어지며, 데이터 정합성이 중요한 애플리케이션에 적합합니다.

- **단점**:

  - 모든 쓰기 작업이 캐시와 DB에 동시에 이루어지므로 성능이 저하될 수 있습니다.
  - 캐시와 DB 모두에 데이터를 저장하므로, 리소스 낭비가 발생할 수 있습니다.
  - 캐시 제공자가 장애를 겪을 경우, 서비스 전체가 중단될 위험이 있습니다.

- **적합한 경우**:
  - 데이터 일관성이 중요한 애플리케이션에서 사용됩니다.
  - 쓰기 작업이 빈번하고, 데이터의 최신성을 유지해야 하는 경우 적합합니다.

## 캐시 무효화 전략

캐시 무효화는 캐시에 저장된 데이터가 더 이상 유효하지 않거나 최신 데이터로 갱신해야 할 때 발생하는 중요한 과정입니다. 올바른 무효화 전략을 사용하지 않으면 캐시와 데이터베이스 간의 데이터 불일치 문제가 발생할 수 있습니다.

### 1. 시간 기반 무효화 (Time-based Invalidation)

- **TTL 설정**: 캐시에 저장된 데이터는 일정 시간이 지나면 자동으로 만료되도록 설정할 수 있습니다. 이 방식은 데이터를 정기적으로 최신 상태로 유지하지만, 데이터가 아직 유효한 경우에도 불필요하게 캐시가 무효화될 수 있습니다.
- **적용 사례**: 정기적으로 업데이트되는 데이터에 적합합니다. 예를 들어, 매일 갱신되는 통계 데이터나 일정 주기로 변경되는 데이터를 캐시할 때 사용됩니다.

### 2. 이벤트 기반 무효화 (Event-based Invalidation)

- **데이터 변경 시 무효화**: 데이터베이스에서 데이터가 변경될 때마다 캐시를 갱신하거나 무효화하는 방법입니다. 이 방식은 캐시와 데이터베이스 간의 데이터 일관성을 보장할 수 있습니다.
- **적용 사례**: 데이터 일관성이 중요한 애플리케이션에서 사용됩니다. 예를 들어, 사용자 프로필 정보와 같은 실시간으로 갱신되어야 하는 데이터에 적합합니다.

### 3. 수동 무효화 (Manual Invalidation)

- **관리자에 의한 무효화**: 시스템 관리자나 개발자가 수동으로 캐시를 무효화하는 방식입니다. 특정 이벤트나 필요에 따라 캐시를 수동으로 제거하거나 갱신할 수 있습니다.
- **적용 사례**: 특정 상황에서만 데이터를 갱신해야 하거나, 예상치 못한 상황에서 캐시를 무효화할 필요가 있는 경우에 적합합니다. 예를 들어, 긴급하게 배포된 변경 사항이 반영되어야 할 때 사용할 수 있습니다.

### 4. 캐시 일관성 관리

- **Write Through 패턴 사용**: 캐시와 데이터베이스를 항상 일치시키기 위해 쓰기 작업을 캐시와 데이터베이스에 동시에 반영하는 패턴입니다.
- **적용 사례**: 데이터 일관성이 매우 중요한 시스템에 적합합니다.

## 캐시 저장 방식 지침

- **저장 데이터 선정**: 자주 사용되며 자주 변경되지 않는 데이터를 캐시에 저장하는 것이 좋습니다.
- **휘발성 데이터**: 캐시는 휘발성을 가지고 있으므로 중요한 정보나 민감한 정보는 캐시에 저장하지 않는 것이 좋습니다.
- **파레토 법칙 적용**: 전체 데이터 중 20%만 캐시에 저장해도 대부분의 사용자를 만족시킬 수 있습니다.

## 캐시 제거 방식 지침

- **만료 정책 설정**: 캐시된 데이터의 만료 시간을 적절히 설정하여 캐시와 DB 간 데이터 정합성을 유지하고, 메모리 부족 문제를 방지합니다.
- **Cache Stampede 방지**: TTL이 짧게 설정된 경우, 캐시 만료 시 다수의 요청이 DB로 몰리며 장애가 발생할 수 있습니다.

## 캐시 공유 방식 지침

- **데이터 충돌 방지**: 캐시 데이터를 변경하기 전에 데이터가 변경되지 않았는지 확인하거나, 캐시 데이터를 업데이트하기 전에 Lock을 사용하여 충돌을 방지합니다.

## 캐시 가용성 지침

- **서비스 지속성 보장**: 캐시 서버 장애 시에도 DB에서 데이터를 가져와 서비스가 지속될 수 있도록 설계해야 합니다. 데이터의 영속성은 캐시가 아닌 기존 데이터 스토어에 위임해야 합니다.

# 참고 자료

[Redis 캐시 설계 전략 정리](https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EC%BA%90%EC%8B%9CCache-%EC%84%A4%EA%B3%84-%EC%A0%84%EB%9E%B5-%EC%A7%80%EC%B9%A8-%EC%B4%9D%EC%A0%95%EB%A6%AC)
