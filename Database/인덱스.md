# 인덱스

- RDBMS에서는 데이터를 효율적으로 탐색하기 위해서 인덱스라는 기능을 제공한다.
- 인덱스란 책의 목차와 같이 데이터를 빠르게 탐색할 수 있도록 따로 접근 위치에 대한 정보를 모아둔 데이터이다.
- 효율적인 검색을 위해서 데이터베이스에 검색 조건에 자주 등장하는 컬럼을 인덱스로 생성한다.
- 데이터를 빠르게 탐색하기 위해서 인덱스는 항상 정렬된 상태를 유지한다.

### 인덱스의 트레이드 오프

- 인덱스는 정렬된 상태를 유지해야 하기 때문에 추가/수정/삭제 에서의 성능은 떨어진다.
- 그래도 대부분의 경우에는 조회기능을 주로 사용하기 때문에 큰 문제가 되지 않고 조회기능의 성능을 높이는게 더 중요하다.

# 인덱스 구조

인덱스는 기본적으로 #B-Tree 형태로 구성되어 있지만 RDBMS에 따라서 B+Tree 를 쓰기도 한다.

B-Tree는 크게 세 부분으로 나뉘어져 있다.

- 루트 노드
- 브랜치 노드
- 리프 노드

루트 노드와 브랜치 노드는 비슷한 형태로 `인덱스 키`와 `자식노드 주소`를 가지고 있다.
리프노드에는 `인덱스 키`와 `프라미머리 키`를 가지고 있어 데이터 파일의 위치를 가리킨다.

인덱스는 트리 구조를 활용해 프라이머리 키로 정렬되어 있기 때문에 위와 같이 데이터를 전부 탐색하지 않고 데이터의 위치를 트리형태로 탐색하는게 가능하다.

# 인덱스 키 검색

인덱스가 위와 같은 구조를 가지고 있어 검색할때의 특징이 몇가지 존재한다.

- <>와 같이 부정일치 검색은 인덱스를 사용하지 못한다.
- 인덱스의 키값이 변형된 후에 검색하면 인덱스를 사용하지 못한다.
- LIKE 검색 후방일치의 경우에도 인덱스를 사용하지 못한다.
- 비교하고자 하는 데이터의 타입이 다른 경우에도 인덱스를 사용하지 못한다.
- 문자열 데이터 타입의 콜레이션이 다른 경우
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교조건에 사용된 경우

# B-Tree 인덱스 사용에 영향을 미치는 요소

- 인덱스 키 값의 크기
  - 디스크에 데이터를 저장하고 읽는 기본 단위는 페이지 또는 블록 단위이다.
  - B-Tree의 각 노드가 관리하는 인덱스 데이터의 단위 또한 페이지이다. (InnoDB 기본 값 = 16KB)
  - 각 노드(16KB)에 담길 수 있는 인덱스 (key, value)의 개수는 각 노드가 가질 수 있는 인덱스 키 값의 크기와 연관이 되어있다. (value는 다른 자식 노드의 주소이기 때문에 고정적이다.)
  - 따라서 인덱스 키 값의 크기가 커지면 하나의 노드가 가지고 있을 수 있는 인덱스 키의 개수가 줄어들면서 효율이 줄어들게 된다.
- B-Tree의 깊이
  - 인덱스 트리의 깊이가 깊어질수록 찾아가는 단계가 많아지는 문제(오버헤드)가 증가한다.
  - 인덱스 트리의 깊이를 직접 조절할 수 있는 방법은 없다.
  - 인덱스 키 값의 크기를 최소화해 깊이가 깊어지지 않도록 해야한다.
- 읽어야 하는 레코드 수
  - 인덱스를 이용하면 레코드를 직접 읽는 것 보다 한단계가 추가된다. 그러므로 읽어야하는 레코드의 수도 고려해야 한다.
  - 카디널리티가 높은 필드에 필터 조건을 추가하는걸 고려해 인덱스의 활용도를 높여야 한다.
- 유니크 속성
  - 유니크 제약조건을 걸면 데이터를 하나 찾았을때 탐색을 종료하므로 검색 과정을 최적화할 수 있다.

# 인덱스 사용에 대한 분류

- 인덱스 레인지 스캔
  - 인덱스에서 해당 범위에 해당하는 일부 데이터만 읽어서 검색하는 방법이다.
  - `인덱스를 탔다.` 라고 하는 경우이다.
- 인덱스 풀 스캔
  - 인덱스를 처음부터 끝까지 읽는 방법이다.
  - `인덱스를 탔다.`의 범위에 포함되지 않는다.
  - (A, B, C)순서로 복합 인덱스를 구성하고 B나 C를 조건으로 해 검색하는 경우이다.
- [루스 인덱스 스캔](./루스%20인덱스%20스캔.md)
  - 특정 조건에 만족하는 경우 (정렬되어 있을때 최소값만 찾는 경우) 사용되는 스캔 방법이다.
  - 필요한 값만 조사하고 건너띄어서 성능을 최적화한다.
- [인덱스 스킵 스캔](./인덱스%20스킵%20스캔.md)
  - 다중 컬럼 인덱스가 있을 때 첫번째 값이 아닌 값을 조건으로 사용 했을 때 첫번째 조건을 건너뛴 인덱스를 활용해 쿼리를 최적화합니다.
  - 성별과 같이 첫번째 인덱스의 카디널리티가 낮은 경우에만 사용되고 인덱스 스킵 스캔은 항상 보장되는 방법은 아니다.

## 멀티 컬럼 인덱스

- 앞선 컬럼에 의존하는 정렬 순서
  - 멀티 컬럼 인덱스로 인덱스를 구성하게 되면 정렬이 아선 컬럼에 의존해 정렬되어서 순서가 굉장히 중요하다.
- 정렬 방향
  - 정렬 방향은 오름차순 또는 내림차순 정렬이 가능하다
  - mysql5.7버전까지는 인덱스의 정렬 방향 설정이 불가능했지만 mysql8.0버전부터는 정렬방향 순서를 정용할 수 있게 됬다.
- 효율적인 인덱스와 아닌 인덱스
  - 인덱스는 카디널리티가 높은 필드에 설정하는게 좋다.
  - 일치 조건으로 검색하는 필드에 거는게 좋다.
