# 동시성 제어 방법

# 1. 낙관적 동시성 제어(Optimistic Concurrency Control)

- 개념
  - 낙관적 동시성 제어는 충돌이 거의 발생하지 않을 것으로 가정하고, 트랜잭션이 끝나기 전까지는 락을 걸지 않고 작업을 수행한다. 트랜잭션이 끝날 때, 충돌이 발생했는지 확인하고 충돌이 발생한 경우 트랜잭션을 롤백하고 다시 시도한다.
- 장점
  - **비용 절감**: 락을 걸지 않기 때문에 락 관리의 오버헤드가 줄어들어 성능이 향상될 수 있습니다.
  - **스케일링 용이**: 높은 동시성을 요구하는 시스템에서 더 많은 트랜잭션을 처리할 수 있습니다.
- 단점
  - **충돌 시 오버헤드**: 충돌이 자주 발생하는 환경에서는 롤백과 재시도로 인해 성능 저하가 발생할 수 있습니다.
  - **복잡한 구현**: 충돌을 감지하고 처리하는 로직이 복잡해질 수 있습니다.
- 사용 사례
  - 읽기 작업이 빈번하고, 쓰기 충돌이 드믄 시나리오에서 유리합니다.
  - 예를 들어, 대부분의 트랜잭션이 데이터를 읽고 드물게 변경하는 환경에서 적합합니다.

> 참고: typeorm에서는 version이라는 필드를 생성한 후에 typeorm의 versionColumn()어노테이션을 통해 충돌감지 여부를 판단할 수 있다.
> 다만, 충돌 이후 처리 과정은 비즈니스 로직으로 구현해주어야 한다.

# 2. 비관적 동시성 제어(Pessimistic Concurrency Control)

- 개념
  - **비관적 동시성 제어**는 충돌이 발생할 가능성이 높다고 가정하고, 데이터를 수정하기 전에 락을 걸어 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 합니다. 즉, 트랜잭션이 데이터를 읽거나 쓸 때마다 다른 트랜잭션이 같은 데이터에 접근하는 것을 방지합니다.
- 장점
  - **충돌 방지**: 충돌을 사전에 방지하므로 트랜잭션이 항상 성공적으로 완료됩니다.
  - **데이터 일관성 보장**: 충돌이 발생하지 않으므로 데이터 일관성을 확실히 유지할 수 있습니다.
- 단점
  - **성능 저하**: 락을 많이 사용하면 대기 시간이 늘어나고, 동시 처리 성능이 떨어질 수 있습니다.
  - **교착 상태(Deadlock) 발생 가능성**: 여러 트랜잭션이 서로 락을 대기하게 되면 교착 상태가 발생할 수 있습니다.

# 두 방법 비교 요약

- **낙관적 방법**: 충돌이 드물 것으로 예상되는 경우 유리하며, 락을 최소화하여 시스템의 성능을 높일 수 있습니다. 하지만 충돌이 발생하면 롤백 및 재시도를 해야 하므로 그 과정에서 성능 저하가 발생할 수 있습니다.
- **비관적 방법**: 충돌이 자주 발생할 수 있는 상황에서는 안전하며, 락을 통해 데이터의 일관성을 확실히 보장할 수 있습니다. 그러나 락이 많아지면 시스템의 동시 처리 성능이 저하될 수 있습니다.
